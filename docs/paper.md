---
title: SPARQL Query Transformation for Generalized Access Control
author: Nathaniel Rudavsky-Brody
---

# Introduction

`mu.semte.ch` is a platform for "building state-of-the-art web applications fuelled by Linked-Data aware microservices".[^mu] It has been used in production to build large systems...

[^mu]: See Versteden and Pauwels, "State-of-the-art Web Applications using Microservices and Linked Data"... and http://mu.semte.ch

One of the advantages of such a platform is the ability to reuse microservices between applications. However, reuse is complicated by the fact that different applications can use very different authorization models and graph structures.

Here we propose a general solution to this problem, based on dynamic query transformation. The Mu Query Rewriter is a proxy service for enriching and constraining SPARQL queries before they are sent to the database. It allows for the abstract expression of complex authorization schemes, greatly simplifying what each microservice needs to know about graph structure and access rules.

Furthermore, it provides a system of query annotations to facilitate integration with the Mu Cache, `mu.semte.ch`'s flexible cache service, allowing authorization-aware caching and cache-clearing.

# Basic Architecture

The Mu Query Rewriter runs as a proxy service in front of the database, handling SPARQL queries sent by the application's microservices. These microservices are expected to pass on the HTTP `mu-session-id` header provided by the Mu Identifier; this header, in conjunction with a log-in service, identifies the URI of the current user.

Conceptually speaking, the access rules are expressed as a dynamic *constraint* expressed in standard SPARQL, namely as a `CONSTRUCT` query. The constraint is thought of as constructing an intermediate *constraint graph* on which incoming SPARQL queries are run. Since the constraint can depend on `mu-session-id` header, the constraint graph will be different for each user.

In practice, an incoming query is optimally rewritten to a form which, when run against the full database, is equivalent to the original query being run against the constraint graph. The result is effectively run against the subset of data which the current user has permission to query or update. 

![](../rewriter.png)

In the following example, the constraint defines a model where bikes and cars are stored in separate graphs, and users can be authorized to see one or both of the types. rdf:type is declared as a "functional property" (see below).

As a simple example, here is a constraint describing a database where triples whose subject have type `<Car>` are stored in the `<cars>` graph, and `<Bike>`s in the `<bikes>` graph. The `<auth>` graph contains triples specifying which users are authorized to see which types. The placeholder `<SESSION>` is dynamically replaced with the `mu-session-id` header.

```
PREFIX mu: <http://mu.semte.ch/vocabularies/core/>

CONSTRUCT {
  ?a ?b ?c
}
WHERE {
  GRAPH ?graph {
   ?a ?b ?c;
      a ?type
  }
  GRAPH <auth> {
   <SESSION> mu:account ?user.
   ?user <authFor> ?type
  }
  VALUES (?graph ?type){
    (<cars> <Car>)
    (<bikes> <Bike>)
  }
}
```

When a microservice sends the a simple query like the following:

```
SELECT *
WHERE {
  ?s a <Bike>;
     <hasColor> ?color.
}
```

the Query Rewriter transforms it into a more complex query which is run against the database:

```
PREFIX mu: <http://mu.semte.ch/vocabularies/core/>

SELECT ?s ?color
WHERE {
  GRAPH ?graph23694 {
    ?s a <Bike>;
       <hasColor> ?color.
  }
  GRAPH <auth> {
   <session123456> mu:account ?user.
   ?user <authFor> <Bike>
  }
  VALUES (?graph23694) { (<bikes>) }
}
```

The results are returned to the microservice.


# Constraint Transformation

The query transformation process ...

-- minimal variable dependency
-- values vs. filter 
-- nested ...
-- ..
-- optimization
-- optimizations

# Annotations and Mu Cache Integration

The Mu Query Rewriter 

# Performance and Caching

Clearly, the Query Rewriter .. latency .. Adding the fact that queries become more complex and thus slower to run, we might expect a serious impact on application performance.

In part, this impact is compensated by the benefits of authorization-aware caching. However, performance can also be vastly improvived by taking into account the fact that most of the queries it receives are generated by a small number of microservices. Therefore we introduce the notion of cache forms, to allow caching on identity modulo URIs and string literals.

# Challenges

There is one important class of challenges which are not addressed in the proof of concept application described below.

## The Incomplete Model

## Model Changes

# Proof of Concept